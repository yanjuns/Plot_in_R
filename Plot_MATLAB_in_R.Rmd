---
title: "Plot_in_R"
author: "Yanjun Sun"
date: "6/28/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

### the Goal of this file is to take advantage of ggplot in R to generate plot from MATLAB data

## setup
```{r setup, message = FALSE, warning = FALSE, results = 'hide'}
#search required packages, install them if missing
pkgs_needed = c("dplyr", "ggplot2", "R.matlab", "tidyr", "BiocManager", "mixtools")
letsinstall = setdiff(pkgs_needed, installed.packages()) 
if (length(letsinstall) > 0) {
  BiocManager::install(letsinstall)
}

#load required packages
library("dplyr")
library("ggplot2")
library("R.matlab")
library("tidyr")
library("BiocManager")
library("rhdf5")

```


## Load data from MATLAB and tranform it into data frame
```{r}
#load .mat file to R and change it to data frame
mat_data <- readMat("Test_Saline.mat") #can only read MAT v7 file and below
mat_data <- h5read("Test_Saline.mat", "corr_LR_saline_pc") # can read MAT v7.3 file, but need to specify var name

r_data <- data.frame(mat_data)

#rename and transform
r_data <- dplyr::rename(r_data, Baseline1 = X1,  Baseline2 = X2, Test1 = X3, Test2 = X4)
my_data <- gather(r_data, Baseline1, Baseline2, Test1, Test2, key = "condition", value = "correlation")
head(my_data)
```

## Generate violin or plots
```{r fig.width = 5, fig.height = 5}
#make an violin plot
ggplot(my_data, aes(x = condition, y = correlation)) + 
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75)) +
  geom_jitter(aes(color = condition), alpha = 0.25, width = 0.2, height = 0)

#make a box plot
ggplot(my_data, aes(x = condition, y = correlation)) + 
  geom_boxplot() +
  geom_jitter(aes(color = condition), alpha = 0.25, width = 0.2, height = 0)
```

## Generate histogram plots
```{r}
#make a histogram of whole data
ggplot(my_data, aes(x = correlation)) +
  geom_histogram(bins = 50)

#make a histogram with facet
my_data2 <- select(my_data, correlation) #select specific data using dplyr::select
ggplot(my_data, aes(x = correlation, fill = condition)) +
  geom_histogram(data = my_data2, bins = 100, fill = "grey", alpha = 0.5) +
  geom_histogram(bins = 100) + 
  facet_wrap(~ condition, ncol = 2)

```
## Generate eCDF plots
```{r}
ggplot(my_data, aes(x = correlation, color = condition)) + 
  stat_ecdf(geom = "step", size = 1) +
  facet_wrap(~ condition, ncol = 2) +
  ylab("Cumulative proportion")

```
## Statistic tests
```{r}
x = dplyr::filter(my_data, condition == "Baseline2")
y = dplyr::filter(my_data, condition == "Test1")
stat_test = t.test(x$correlation, y$correlation, paired = TRUE, alternative = "two.sided")
stat_test

```

## try mixtures for correlations
```{r}
library("mixtools")
gm2 =normalmixEM(my_data2[[1]], k = 2, lambda =c(0.5, 0.5), mu =c(0.2, 0.75), sigma =c(0.1, 0.1))
gm3 =normalmixEM(my_data2[[1]], k = 3, lambda =c(0.5, 0.5, 0.5), mu =c(-0.1, 0.2, 0.75), sigma =c(0.1, 0.1, 0.1))

comp1 = tibble(x =seq(-1, 1, length.out =1000),f = gm3[["lambda"]][1]*dnorm(x, mean = gm3[["mu"]][1], sd = gm3[["sigma"]][1])) 
                     
comp2 = tibble(x =seq(-1, 1, length.out =1000), f = gm3[["lambda"]][2]*dnorm(x, mean = gm3[["mu"]][2], sd = gm3[["sigma"]][2]))

# comp3 = tibble(x =seq(-1, 1, length.out =1000), f = gm3[["lambda"]][3]*dnorm(x, mean = gm3[["mu"]][3], sd = gm3[["sigma"]][3]))

ggplot(comp1, aes(x = x, y = f)) +
  geom_line(color ="red", size =1.5) +
  geom_line(data = comp2, size = 1.5) +
  ylab("mixture density")

# ggplot(comp1, aes(x = x, y = f)) +
#   geom_line(color ="red", size =1.5) +
#   geom_line(data = comp2, size = 1.5) +
#   geom_line(data = comp3, size = 1.5) +
#   ylab("mixture density")

```